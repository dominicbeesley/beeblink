//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//
// BeebLink - BBC Micro file storage system
// Copyright (C) 2018 Tom Seddon
// 
// This program is free software: you can redistribute it and/or
// modify it under the terms of the GNU General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
// General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see
// <https://www.gnu.org/licenses/>.
//
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

#include <stdint.h>
#include "serial.h"
#include <avr/pgmspace.h>
#include <LUFA/Common/Common.h>
#include <LUFA/Drivers/USB/USB.h>
#include "board.h"

#if SERIAL_ENABLED

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

// screen /dev/cu.wchusbserial14220 115200
//
// C-a C-\ to quit

/* anything faster seems unreliable, at least with the crappy
 * WinChipHead thing I've got... */
#define SERIAL_BPS (115200)
#define BIT_DELAY_US (1000000.0/SERIAL_BPS)

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

static uint8_t g_enabled=1;

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

void serial_init(void) {
    SERIAL_DDR|=SERIAL_MASK;
    SERIAL_PORT|=SERIAL_MASK;

    serial_ch('\n');
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

uint8_t serial_is_enabled(void) {
    return g_enabled;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

void serial_set_enabled(uint8_t enabled) {
    g_enabled=enabled;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

void serial_ch(char ch) {
    if(!g_enabled) {
        return;
    }
    
    uint8_t set=SERIAL_PORT|SERIAL_MASK,reset=SERIAL_PORT&~SERIAL_MASK;
    
    cli();

#define BIT(VALUE) (SERIAL_PORT=(VALUE)?reset:set);_delay_us(BIT_DELAY_US)
    
    BIT(0);
    BIT(ch&0x01);
    BIT(ch&0x02);
    BIT(ch&0x04);
    BIT(ch&0x08);
    BIT(ch&0x10);
    BIT(ch&0x20);
    BIT(ch&0x40);
    BIT(ch&0x80);
    BIT(1);
    
    sei();
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

void serial_ps(const char *ps) {
    if(!g_enabled) {
        return;
    }
    
    char c;

    while((c=pgm_read_byte(ps++))) {
	serial_ch(c);
    }
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

void serial_u8(uint8_t u) {
    if(!g_enabled) {
        return;
    }
    
    serial_ch('0'+(u/100)%10);
    serial_ch('0'+(u/10)%10);
    serial_ch('0'+(u/1)%10);
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

void serial_u16(uint16_t u) {
    if(!g_enabled) {
        return;
    }
    
    serial_ch('0'+(u/10000)%10);
    serial_ch('0'+(u/1000)%10);
    serial_ch('0'+(u/100)%10);
    serial_ch('0'+(u/10)%10);
    serial_ch('0'+(u/1)%10);
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

void serial_u32(uint32_t x) {
    if(!g_enabled) {
        return;
    }
    
    serial_ch('0'+(x/1000000000L)%10);
    serial_ch('0'+(x/100000000L)%10);
    serial_ch('0'+(x/10000000L)%10);
    serial_ch('0'+(x/1000000L)%10);
    serial_ch('0'+(x/100000L)%10);
    serial_ch('0'+(x/10000L)%10);
    serial_ch('0'+(x/1000L)%10);
    serial_ch('0'+(x/100L)%10);
    serial_ch('0'+(x/10L)%10);
    serial_ch('0'+(x/1L)%10);
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

void serial_x4(uint8_t x) {
    if(!g_enabled) {
        return;
    }
    
    x&=15;
    if(x<10) {
	serial_ch('0'+x);
    } else {
	serial_ch('A'+x-10);
    }
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

void serial_x8(uint8_t x) {
    serial_x4(x>>4);
    serial_x4(x>>0);
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

void serial_x16(uint16_t x) {
    serial_x8(x>>8);
    serial_x8(x>>0);
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

void serial_x24(uint32_t x) {
    serial_x8(x>>16);
    serial_x16(x);
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

void serial_x32(uint32_t x) {
    serial_x8(x>>24);
    serial_x24(x);
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

#endif
