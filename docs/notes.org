* Random notes

Brain dump that's on GitHub so I have a backup.

* Speed tests

Back-of-the-envelope calculations to give peak plausible-ish throughput, for actual code that might actually run from a ROM.

BBC->server:

: lda (ptr),Y   ; +5 = 5   assume no page crossing
: sta via+0     ; +6 = 11
: lda #$10      ; +2 = 13
: -
: bit via+13    ; +6 = 19
: beq -         ; +2 = 21  assume branch not taken
: iny           ; +2 = 23

So 23N+3 for N unrolls, or 2e6/((23*N+3)/N). For 1 page:

1x = 75.12KBytes/sec
2x = 79.72KBytes/sec
4x = 82.24KBytes/sec
8x = 83.56KBytes/sec

Server->BBC:

: stx via+0     ; +6 = 6   arbitrary value to set the handshaking off
: lda #$10      ; +2 = 8
: -
: bit via+13    ; +6 = 14
: beq -         ; +2 = 16  assume branch not taken
: lda via+0     ; +6 = 22
: sta (ptr),Y   ; +6 = 28
: iny           ; +2 = 30

So 30N+3 for N unrolls, or 2e6/((30*N+3)/N). For 1 page:

1x = 59.19KBytes/sec
2x = 62.00KBytes/sec
4x = 63.52KBytes/sec
8x = 64.30KBytes/sec

Parasite throughput will be a bit faster in each case since there's no
need for indexing. But it's 10uS/byte so peak throughput is 100,000
bytes/sec.

** Base

as at 3d8d71fef08f9e7c457b5f600f50e98f09ba6fed:

SERVER: Host<->server: 116,736 bytes in 4 tests
SERVER:   Send: 50.89 KBytes/sec
SERVER:   Recv: 45.42 KBytes/sec
SERVER: Parasite<->server: 122,880 bytes in 4 tests
SERVER:   Send: 54.05 KBytes/sec
SERVER:   Recv: 47.43 KBytes/sec

** Parasite pagewise send tweak

There are obvious minor inefficiencies here.

Store VIA IFR mask in A, use BIT to test IFR, and X to store the byte.
Save 2 cycles each time.

SERVER: Host<->server: 112,640 bytes in 4 tests
SERVER:   Send: 50.93 KBytes/sec
SERVER:   Recv: 45.45 KBytes/sec
SERVER: Parasite<->server: 122,880 bytes in 4 tests
SERVER:   Send: 60.30 KBytes/sec
SERVER:   Recv: 47.24 KBytes/sec

Conclusion: yes.

** Parasite pagewise send unroll

Unroll 2x (no branch tweaks required)

SERVER: Host<->server: 116,736 bytes in 4 tests
SERVER:   Send: 50.89 KBytes/sec
SERVER:   Recv: 45.24 KBytes/sec
SERVER: Parasite<->server: 122,880 bytes in 4 tests
SERVER:   Send: 62.18 KBytes/sec
SERVER:   Recv: 46.88 KBytes/sec

Unroll 4x (no branch tweaks required)

SERVER: Host<->server: 116,736 bytes in 4 tests
SERVER:   Send: 50.89 KBytes/sec
SERVER:   Recv: 45.24 KBytes/sec
SERVER: Parasite<->server: 122,880 bytes in 4 tests
SERVER:   Send: 63.83 KBytes/sec
SERVER:   Recv: 47.43 KBytes/sec

Unroll 8x (with branch tweaks)

SERVER: Host<->server: 291,840 bytes in 10 tests
SERVER:   Send: 50.80 KBytes/sec
SERVER:   Recv: 45.24 KBytes/sec
SERVER: Parasite<->server: 307,200 bytes in 10 tests
SERVER:   Send: 63.69 KBytes/sec
SERVER:   Recv: 47.39 KBytes/sec

Unroll 16x (with branch tweaks)

SERVER: Host<->server: 291,840 bytes in 10 tests
SERVER:   Send: 50.98 KBytes/sec
SERVER:   Recv: 45.31 KBytes/sec
SERVER: Parasite<->server: 307,200 bytes in 10 tests
SERVER:   Send: 63.56 KBytes/sec
SERVER:   Recv: 47.39 KBytes/sec

Conclusion: stick with 4x.

** AVR USB_USBTask

Call USB_USBTsask a lot less often when waiting for BBC to become
ready. (Maintain a uint16_t counter. When it's 0 after incrementing,
call USB_USBTsask.)

Unroll 4x (no branch tweaks required):

SERVER: Host<->server: 291,840 bytes in 10 tests
SERVER:   Send: 70.72 KBytes/sec
SERVER:   Recv: 58.40 KBytes/sec
SERVER: Parasite<->server: 307,200 bytes in 10 tests
SERVER:   Send: 71.43 KBytes/sec
SERVER:   Recv: 59.76 KBytes/sec

Unroll 8x (with branch tweaks):

SERVER: Host<->server: 291,840 bytes in 10 tests
SERVER:   Send: 70.37 KBytes/sec
SERVER:   Recv: 58.40 KBytes/sec
SERVER: Parasite<->server: 307,200 bytes in 10 tests
SERVER:   Send: 70.75 KBytes/sec
SERVER:   Recv: 59.64 KBytes/sec

Unroll 16x (with branch tweaks):

SERVER: Host<->server: 291,840 bytes in 10 tests
SERVER:   Send: 70.72 KBytes/sec
SERVER:   Recv: 58.40 KBytes/sec
SERVER: Parasite<->server: 307,200 bytes in 10 tests
SERVER:   Send: 70.92 KBytes/sec
SERVER:   Recv: 60.00 KBytes/sec

Conclusion: this is a good change.

** Parasite pagewise recv tweak

Store VIA IFR mask in A, use BIT to test IFR, and X to store the byte.
Save 2 cycles each time.

SERVER: Host<->server: 291,840 bytes in 10 tests
SERVER:   Send: 70.54 KBytes/sec
SERVER:   Recv: 58.28 KBytes/sec
SERVER: Parasite<->server: 307,200 bytes in 10 tests
SERVER:   Send: 71.26 KBytes/sec
SERVER:   Recv: 63.83 KBytes/sec

** Parasite pagewise recv unroll

Unroll 2x (no branch tweaks required):

SERVER: Host<->server: 291,840 bytes in 10 tests
SERVER:   Send: 70.90 KBytes/sec
SERVER:   Recv: 58.52 KBytes/sec
SERVER: Parasite<->server: 307,200 bytes in 10 tests
SERVER:   Send: 71.26 KBytes/sec
SERVER:   Recv: 67.72 KBytes/sec

Unroll 4x (no branch tweaks required):

SERVER: Host<->server: 291,840 bytes in 10 tests
SERVER:   Send: 70.37 KBytes/sec
SERVER:   Recv: 58.28 KBytes/sec
SERVER: Parasite<->server: 307,200 bytes in 10 tests
SERVER:   Send: 70.92 KBytes/sec
SERVER:   Recv: 66.37 KBytes/sec

Unroll 8x (with branch tweaks):

SERVER: Host<->server: 291,840 bytes in 10 tests
SERVER:   Send: 70.54 KBytes/sec
SERVER:   Recv: 58.52 KBytes/sec
SERVER: Parasite<->server: 307,200 bytes in 10 tests
SERVER:   Send: 70.92 KBytes/sec
SERVER:   Recv: 67.26 KBytes/sec

Unroll 16x not reliably any quicker.

Conclusion: 2x = good.

** Tweak parasite stragglers recv loop

Make sure it's exactly 48 cycles in the fastest route through. Result
appears to be noise.

SERVER: Host<->server: 291,840 bytes in 10 tests
SERVER:   Send: 70.54 KBytes/sec
SERVER:   Recv: 58.40 KBytes/sec
SERVER: Parasite<->server: 307,200 bytes in 10 tests
SERVER:   Send: 70.92 KBytes/sec
SERVER:   Recv: 68.03 KBytes/sec

** Tweak parasite stragglers send loop

Ditto. Pretty sure this difference is just noise...

SERVER: Host<->server: 291,840 bytes in 10 tests
SERVER:   Send: 70.72 KBytes/sec
SERVER:   Recv: 58.16 KBytes/sec
SERVER: Parasite<->server: 307,200 bytes in 10 tests
SERVER:   Send: 71.09 KBytes/sec
SERVER:   Recv: 67.87 KBytes/sec

** Tweak host send pagewise loop

SERVER: Host<->server: 291,840 bytes in 10 tests
SERVER:   Send: 70.90 KBytes/sec
SERVER:   Recv: 58.40 KBytes/sec

Unroll 2x

SERVER: Host<->server: 291,840 bytes in 10 tests
SERVER:   Send: 76.61 KBytes/sec
SERVER:   Recv: 58.40 KBytes/sec

Unroll 4x

SERVER: Host<->server: 291,840 bytes in 10 tests
SERVER:   Send: 73.83 KBytes/sec
SERVER:   Recv: 58.40 KBytes/sec

Conclusion: 2x = good

** Tweak host recv pagewise loop

Unroll 2x

SERVER: Host<->server: 291,840 bytes in 10 tests
SERVER:   Send: 76.82 KBytes/sec
SERVER:   Recv: 60.25 KBytes/sec

Unroll 4x

SERVER: Host<->server: 291,840 bytes in 10 tests
SERVER:   Send: 76.61 KBytes/sec
SERVER:   Recv: 61.29 KBytes/sec

Unroll 8x

SERVER: Host<->server: 291,840 bytes in 10 tests
SERVER:   Send: 76.82 KBytes/sec
SERVER:   Recv: 61.29 KBytes/sec

Conclusion: 4x = good

Hardly seems worth bothering with the straggler loops. There's no real
fat there.

** Parasite pairwise send

Before:

SERVER: Parasite<->server: 307,200 bytes in 10 tests
SERVER:   Send: 71.09 KBytes/sec
SERVER:   Recv: 67.87 KBytes/sec

One pair per iteration:

SERVER: Parasite<->server: 309,750 bytes in 10 tests
SERVER:   Send: 62.63 KBytes/sec
SERVER:   Recv: 69.06 KBytes/sec

Unroll 2x:

SERVER: Host<->server: 294,390 bytes in 10 tests
SERVER:   Send: 77.28 KBytes/sec
SERVER:   Recv: 61.69 KBytes/sec
SERVER: Parasite<->server: 309,750 bytes in 10 tests
SERVER:   Send: 62.37 KBytes/sec
SERVER:   Recv: 68.90 KBytes/sec

Not going to bother doing any more with this. The code is still there,
just toggled out.

* AVR code tweaks

Before (I think - reconstituted from the above):

SERVER: Host<->server: 294,390 bytes in 10 tests
SERVER:   Send: 77.28 KBytes/sec
SERVER:   Recv: 61.69 KBytes/sec
SERVER: Parasite<->server: 307,200 bytes in 10 tests
SERVER:   Send: 71.09 KBytes/sec
SERVER:   Recv: 67.87 KBytes/sec

Macroize various bits.

SERVER: Host<->server: 294,390 bytes in 10 tests
SERVER:   Send: 74.87 KBytes/sec
SERVER:   Recv: 61.69 KBytes/sec
SERVER: Parasite<->server: 309,750 bytes in 10 tests
SERVER:   Send: 81.31 KBytes/sec
SERVER:   Recv: 68.90 KBytes/sec

Macroize *everything*. Not sure this does much for the readability,
but it doesn't hurt the speed...

SERVER: Host<->server: 294,390 bytes in 10 tests
SERVER:   Send: 78.12 KBytes/sec
SERVER:   Recv: 61.96 KBytes/sec
SERVER: Parasite<->server: 309,750 bytes in 10 tests
SERVER:   Send: 84.26 KBytes/sec
SERVER:   Recv: 69.22 KBytes/sec

Rough figures:

Host send = 2000000/(78.12*1024) = 25 cycles/bytes
Host recv = 2000000/(61.96*1024) = 31.5 cycles/byte
Parasite send = 2000000/(84.26*1024) = 23.2 cycles/byte
Parasite recv = 2000000/(69.22*1024) = 28.2 cycles/byte

Since the host recv case hardly improved due to the AVR code tweaks,
the limit is presumably the 6502 code in that case. (Not sure there's
a vast amount to be squeezed out there, but, maybe...)

The host send/recv cases are now the 6.5 cycles apart you'd expect.
Recv is always going to be ~6-7 cycles slower, because there's an
extra 1MHz read, and the (zp),Y write always takes 6 cycles
(*SPEEDTEST transfers page-aligned data so the send case never hits
the page boundary crossin when reading).

The fact parasite recv is only 5 cycles slower than send is a bit
suspicious. Is there a bit more to be squeezed out here?

Add fast path for non-verbose large transfers:

SERVER: Host<->server: 294,390 bytes in 10 tests
SERVER:   Send: 78.55 KBytes/sec
SERVER:   Recv: 61.83 KBytes/sec
SERVER: Parasite<->server: 309,750 bytes in 10 tests
SERVER:   Send: 85.69 KBytes/sec
SERVER:   Recv: 69.06 KBytes/sec

2000000/(85.69*1024) = 22.8 cycles/byte

Going to keep this change anyway, because it's the right thing to do,
even if it doesn't make much of a difference...
* Boot notes

Private workspace claim (request type 2) happens early on in the boot
process, and it isn't claimed - so it's a good place to reset the
link-started flag.

ROM boot (request type 3) can be claimed, so there's no guarantee the
BLFS ROM will receive it.

* Serial protocol rambles

The AVR has an OOB mechanism for resets: the USB stall that the BBC
can induce by switching off write handshaking. This is how the BBC can
cancel the current operation, whatever it was, after pressing BREAK,
without things getting out of sync too often.

The serial link needs something similar.

Key thing: there is a certain run of bytes that will never occur
during normal transmission. The BBC can just send this to the server
repeatedly to indicate a reset, and then watch for the same response
from the server. Once both sides have detected it, the buffers have
been flushed, and they can send one another a single sync byte to
indicate they are ready.

Note new serial-specific request type, 0x00:

- =REQUEST_SERIAL_CANCEL= :: 0x00

Special syntax, same as =REQUEST_AVR_PRESENCE=: it's a valid request
just on its own (whether fixed- or variable-size payload), and there's
never any payload. When received, it puts the server immediately into
sync mode.

** sync mode

Sync mode allows both sides to flush all necessary buffers (FTDI
buffer for the BBC, FTDI buffer + various OS buffers for the server)
and put themselves in a known state.

Server side:

1. emit =num_required_0s= x $00 bytes followed by 1 x $01 byte. This
   can be done as one lump, at the start of the process; the data will
   be buffered up and will appear at the BBC end in due course

2. read data from the BBC, counting runs of $00 bytes and discarding
   everything else. When =num_required_0s= consecutive $00 bytes have
   been received, go to step 3

3. read bytes from BBC: a $01 indicates sync complete, and it's done;
   $00 bytes should be ignored; other values are an error

BBC side:

1. emit a single $80 byte to break any run of $00s that might have
   been in progress as part of a previous sync that was interrupted by
   BREAK

2. emit continuous $00 bytes while reading from the server. Count runs
   of zeroes and discard everything else. When =num_required_0s=
   consecutive $00 bytes have been received, go to step 2.

3. continue emitting $00 bytes. Read bytes from server: a $01
   indicates sync complete, so go to step 3; $00s can be ignored;
   other values are an error

4. emit a single $01 byte to indicate that sync is complete

At this point, fingers crossed, they're both in sync...

260 bytes = 2,340 bits, or 0.02 sec at 115,200 baud (and actual
transmit rate will be higher).

** request formats

Fixed size request: 1 byte type (bit 7 clear), 1 byte payload, 1 byte
confirmation.

Variable size request: 1 byte type (bit 7 set), 4 bytes LE payload
size, N bytes of payload. The payload includes confirmation bytes (see
below), which are not included in the size.

Responses have the same format as requests, including confirmation
bytes.

** confirmation bytes

Payloads include confirmation bytes at particular points. The
confirmation bytes indicate whether there's more data to come, or that
the request has been canceled. The payload is also always followed by
a final confirmation byte, indicating that the request was valid or
that it was canceled (at the last possible moment).

To indicate cancelation, supply 0x00 or 0x80 (i.e.,
=REQUEST_SERIAL_CANCEL=). Otherwise, supply 0x01. There's no real plan
for additional values, but... maybe??

Requests include these bytes, so the BBC can indicate that it's
canceling a request. (Canceling a request puts the server into sync
mode.)

Responses include these bytes, so that there's never a long enough run
of 0x00 bytes to cause data to be confused with sync. But since the
server never cancels a response, the confirmation bytes in a response
are always 0x01 and the BBC can just ignore them.

Mid-payload confirmation bytes should be included based on each byte's
negative offset: =(payload size)-(offset of byte)=. (The last byte's
negative offset is =-1=, and the first byte's is =-(payload size)=.)
If the LSB of the negative offset is 0, send a confirmation byte
before sending the byte.

This arrangement is not super logical, just easy to handle efficiently
from the 6502 side.

** forcing a reset from the BBC side

For use the first time the FS is activated after a reset.

Just embark on sync mode from the BBC side...

If the server was waiting for a response, it will get the =0= and go
into syn mode straight away.

If a response was being sent, this will ensure the server eventually
hits the point where it's expecting a confirmation byte, and then
supply a 0 for that byte. Now the PC is in sync mode too.

If a response was being received: the PC will be listening. If it
receives a =REQUEST_SERIAL_CANCEL= byte while sending, it will go into
sync mode. (It will do this immediately, as the BBC must know that
it's done this and won't be listening for proper packet data any
more.)

Either way, eventually both will end up in sync part 1 at the same
time, and then sync part 2.

** what is the right value for =num_required_0s=?

I think 259 is enough, so of course it's probably going to stay
at 500.

Worst case is a variable size 255 byte packet of 0s, with a run of 258
0 bytes:

: +000 xx (type)
: +001 ff + size
: +002 00 |
: +003 00 |
: +004 00 +
: +005 00 (byte 0, negative offset 0xffffff01)
: ..
: +104 00 (byte fe, negative offset 0x00000000)
: +105 01 confirmation byte

Any payload with a size of $xxxxxxff will potentially start with 255
0s, but larger sizes will have fewer 0s as part of the size.

Payloads with size $xxxxxx00 (obviously $xxxxxx>=1...) have 254 0
bytes in the worst case:

: +000 xx (type)
: +001 00 + size
: +002 01 |
: +003 00 |
: +004 00 +
: +005 00 (byte 0, negative offset 0xffffff00)
: +006 01 (confirmation byte)
: ..
: +105 00 (byte ff, negative offset 0x00000000)
: +106 01 confirmation byte

* copy/paste fodder

#+begin_src text
          7   6   5   4   3   2   1   0
        +---+---+---+---+---+---+---+---+
  +0    | 0 | request type              |
        +---+---+---+---+---+---+---+---+
  +1    | size bits 0...7               |
        +---+---+---+---+---+---+---+---+
  +2    | size bits 8...15              |
        +---+---+---+---+---+---+---+---+
  +3    | size bits 16...23             |
        +---+---+---+---+---+---+---+---+
  +4    | size bits 24...31             |
        +---+---+---+---+---+---+---+---+
  +5    |   |   |   |   |   |   |   |   |
        .   .   .   .   .   .   .   .   .
  +N+5  |   |   |   |   |   |   |   |   |
        +---+---+---+---+---+---+---+---+
  +N+6  | SERIAL_YES                    |
        +-------------------------------+
#+end_src
