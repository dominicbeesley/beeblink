;-------------------------------------------------------------------------
;
; BeebLink - BBC Micro file storage system
; Copyright (C) 2018 Tom Seddon
; 
; This program is free software: you can redistribute it and/or
; modify it under the terms of the GNU General Public License as
; published by the Free Software Foundation, either version 3 of the
; License, or (at your option) any later version.
; 
; This program is distributed in the hope that it will be useful, but
; WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
; General Public License for more details.
; 
; You should have received a copy of the GNU General Public License
; along with this program. If not, see
; <https://www.gnu.org/licenses/>.
;
;-------------------------------------------------------------------------
;
; The Master host code just gets straight to poking the Tube I/O as
; part of its EVENTV handler:
; 
; Send event across Tube
; ----------------------
; 0682 48          H    PHA
; 0683 A9 00       ).   LDA #&00
; 0685 20 91 06     ..  JSR &0691
; 0688 98          .    TYA
; 0689 20 91 06     ..  JSR &0691
; 068C 8A          .    TXA
; 068D 20 91 06     ..  JSR &0691
; 0690 68          h    PLA
; 
; Send byte in A via R1
; ---------------------
; 0691 2C E0 FE    ,`~  BIT &FEE0
; 0694 50 FB       P{   BVC &0691
; 0696 8D E1 FE    .a~  STA &FEE1
; 0699 60          `    RTS
; 
; So the Tube select bit of ACCCON needs some careful handling. If the
; ITU bit had to be disabled to gain access to the FTDI board, the
; access has to be performed with interrupts disabled.
;
;

                .section code

;-------------------------------------------------------------------------
                
                .virtual $fefe
fifo:
                .endv

                .virtual $feff
status: .block
rx_data=$01
tx_space=$02
suspend=$04
configured=$08
                .bend
                .endv

;-------------------------------------------------------------------------

tube_serial: .block

;-------------------------------------------------------------------------

; The minimum is actually 259 (see the docs/notes.org), but more won't
; hurt.
num_sync_zeros_required=500

                .section link_startup_workspace
num_sync_zeros_received: .fill 2
                .send link_startup_workspace

; The link startup workspace is a not-very-generous 8 bytes.
startup_end_time=brkthunk+0
startup_current_time=brkthunk+5
startup_max_time=1000 ;in centiseconds
                
;-------------------------------------------------------------------------

                .section fs_private_workspace
                ; bit 7 set if M128, using internal Tube.
private_itu: .fill 1
private_send_value: .fill 1
                .send fs_private_workspace

;-------------------------------------------------------------------------
; Check if ACCCON ITU needs resetting to access the FTDI device.
;
; In principle there's a race condition here, and ITU could become
; set. But it looks like the MOS actually just leaves it alone after
; initialisation, so it's all quite safe(tm)...
;
; exit: C=0 if no handling required (B/B+/M128 with ext Tube or no Tube)
;       C=1 if handling required (M128 with int Tube)
; preserves: A; X; Y

is_itu: .proc
                pha
                txa
                pha
                
                ; http://beebwiki.mdfs.net/OSBYTE_&00
                lda #0
                ldx #1
                jsr osbyte

                ; X=0 (Electron), 1 (B), 2 (B+), 3 (Master), 4 (Master
                ; 128), 5 (Master Compact) - all other options appears
                ; to be non-6502.
                cpx #3
                bcc +           ;taken with C=0if not Master

                lda acccon
                and #acccon.itu
                cmp #acccon.itu ;C=1 if int Tube
+

                pla
                tax
                pla
                rts
                .pend

;-------------------------------------------------------------------------
; Reads status register. Handles Tube palaver if required.
;
; exit: A=value of status register
; preserves: Y
safe_read_status: .proc
                jsr is_itu
                bcs +
                lda status
                rts

+
                .cpu '65c02'
                phy
                ldy #status-fifo
                jsr m128_read_register
                ply
                .cpu 'default'
                rts
                .pend

m128_read_register: .proc
                .cpu '65c02'
                php
                sei
                
                ldx acccon
                lda #acccon.itu
                trb acccon
                
                lda fifo,y

                stx acccon
                plp
                .cpu 'default'
                rts
                .pend

;-------------------------------------------------------------------------
; Reads FIFO. Handles Tube palaver if required.
;
; exit: C=0 if no data was available
;       C=1 if data was available, A = value read
; preserves: Y
safe_read_fifo: .proc
                jsr safe_read_status
                and #status.rx_data
                bne got_data

no_data:
                clc             ;no data available
                rts

got_data:
                jsr is_itu
                bcs +
                
                lda fifo
                sec
                rts

+
                .cpu '65c02'
                phy
                ldy #fifo-fifo
                jsr m128_read_register
                sec
                rts
                .cpu 'default'
                .pend

;-------------------------------------------------------------------------
; Writes FIFO. Handles Tube palaver if required.
;
; entry: A=value to write
; exit: C=0 if no space
;       C=1 if data was written
; preserves Y
safe_write_fifo: .proc
                pha
                jsr safe_read_status
                and #status.tx_space
                bne got_space

no_space:
                pla
                clc             ;no space available
                rts

got_space:
                jsr is_itu
                bcs m128_write_fifo

                pla
                sta fifo
                sec
                rts

m128_write_fifo:
                .cpu '65c02'
                php
                sei

                ldx acccon
                lda #acccon.itu
                trb acccon

                pla
                sta fifo

                stx acccon
                plp
                .cpu 'default'
                rts
                .pend
                
;-------------------------------------------------------------------------

startup: .proc

                ; jsr pcprint
                ; .text 'borkork',255

                ; sec
                ; rts

                ldx #25         ;# vsyncs to wait
loop:
                txa
                pha
                
                lda #19
                jsr osbyte

                jsr safe_read_status
                
                ; bit 7 of $feff seems to be reliably set if the Tube
                ; serial board isn't connected.
                cmp #$80
                bcc maybe_present

                pla             ;discard
                jmp not_present

maybe_present:
                ; wait for bit 3 to become set.
                and #status.configured
                cmp #status.configured ;C=1 if bit 3 set

                pla
                tax

                bcs good

                dex
                bne loop
                
not_ready:
                ldx #status_text.device_not_ready-status_text
                sec             ;no good
                rts

not_present:
                ldx #status_text.device_not_present-status_text
                sec             ;no good
                rts

good:

                lda #1          ;read system clock
                ldx #<startup_end_time
                ldy #>startup_end_time
                jsr osword

                .debug_print ['Time now: &',startup_end_time+4,startup_end_time+3,startup_end_time+2,startup_end_time+1,startup_end_time+0,'\r']

                clc
                lda startup_end_time+0
                adc #<startup_max_time
                sta startup_end_time+0
                lda startup_end_time+1
                adc #>startup_max_time
                sta startup_end_time+1
                bcc +
                inc startup_end_time+2
                bne +
                inc startup_end_time+3
                bne +
                inc startup_end_time+4
+
                
                .debug_print ['End time: &',startup_end_time+4,startup_end_time+3,startup_end_time+2,startup_end_time+1,startup_end_time+0,'\r']

start_sync:
                lda #0
                sta num_sync_zeros_received+0
                sta num_sync_zeros_received+1

;                 .block
;                 .debug_print ['Sync step 1...\r']
; sync_step_1_loop:
;                 jsr check_startup_timeout
;                 bcs timed_out
                
;                 lda #$80
;                 jsr safe_write_fifo
;                 bcc sync_step_1_loop
;                 .bend

                .block
                .debug_print ['Sync step 1...\r']
sync_step_1_loop:
                ; .print ['&00: sent: &',num_sync_zeros_sent+1,num_sync_zeros_sent+0,'; received: &',num_sync_zeros_received+1,num_sync_zeros_received+0,'\r']
                jsr check_startup_timeout
                bcs timed_out

                ; Try to write $00. If it didn't get sent, no
                ; problem... plenty more where that came from.
                lda #$00
                jsr safe_write_fifo
                
                ; Try to get more data. If none available, just carry
                ; on looping.
                jsr safe_read_fifo
                bcc sync_step_1_loop

                ; If a non-0 was received, restart the sync process.
                cmp #0
                bne start_sync

                ; Count one more zero received.
                ldx #num_sync_zeros_received
                jsr add1z16

                ; Keep going if required number not reached.
                lda num_sync_zeros_received+0
                cmp #<num_sync_zeros_required
                bne sync_step_1_loop

                lda num_sync_zeros_received+1
                cmp #>num_sync_zeros_required
                bne sync_step_1_loop
                .bend

                .block
                ; Keep reading until the 1 byte is received. Continue
                ; sending zeros meanwhile.
                .debug_print ['Sync step 2...\r']
sync_step_2_loop:
                jsr check_startup_timeout
                bcs timed_out

                ; Try to write $00. If it didn't get sent, no
                ; problem... plenty more where that came from.
                lda #$00
                jsr safe_write_fifo

                jsr safe_read_fifo
                bcc sync_step_2_loop

                cmp #0
                beq sync_step_2_loop

                cmp #1
                bne failed
                .bend

                .block
                ; Send a single non-zero byte.
                .debug_print ['Sync step 3...\r']
sync_step_3_loop:
                jsr check_startup_timeout
                bcs timed_out

                lda #1
                jsr safe_write_fifo
                bcc sync_step_3_loop
                .bend
ok:
                .debug_print ['Sync success (probably)\r']
                clc             ;good
                rts

failed:
                ldx #status_text.sync_failed-status_text
                sec             ;no good
                rts

timed_out:
                ldx #status_text.sync_timed_out-status_text
                sec
                rts


; send_sync_zero:
;                 lda #0
; send_sync_byte:
;                 jsr safe_write_fifo
;                 bcc +           ;taken if write failed

;                 ; ldx #num_sync_zeros_sent
;                 ; jsr add1z16
; +
;                 rts

check_startup_timeout:
                lda #1          ;read system clock
                ldx #<startup_current_time
                ldy #>startup_current_time
                jsr osword

                sec
                .for i=0,i<=4,i+=1
                lda startup_end_time+i
                sbc startup_current_time+i
                .next

                bpl no_timeout

timeout:
                .debug_print ['Timeout time: &',startup_current_time+4,startup_current_time+3,startup_current_time+2,startup_current_time+1,startup_current_time+0,'\r']
                sec
                rts

no_timeout:
                clc
                rts
                
                .pend

status_text: .block
device_not_ready:
                .text 'Device not ready',0
device_not_present:
                .text 'Device not present',0
sync_failed:
                .text 'Sync failed',0
sync_timed_out:
                .text 'Sync timeout',0
                .bend
                
;-------------------------------------------------------------------------
; Prepare link.
;
; Set Master 128 ITU flag... and anything else???
prepare: .proc
                jsr is_itu
                ror private_itu

                bcc +
                .brk_error 255,'Internal Tube = TODO',255
+
                rts
                .pend

;-------------------------------------------------------------------------
; Unprepare link.
;
; (Nothing needs to be done for the Tube serial.)
unprepare: .proc
                rts
                .pend

;-------------------------------------------------------------------------
; Placeholder for stuff I haven't done yet.              
error: .proc
                .brk_error 255,'Tube serial transfer = TODO'
                .pend

;-------------------------------------------------------------------------
; Placeholder for stuff that doesn't need doing.
nop: .proc
                rts
                .pend

;-------------------------------------------------------------------------

wait_for_rx_data: .macro
                lda #status.rx_data
-
                bit status
                beq -
                .endm

wait_for_tx_space: .macro
                lda #status.tx_space
-
                bit status
                beq -
                .endm
                
;-------------------------------------------------------------------------

send_header_byte: .proc
                sta private_send_value
                .wait_for_tx_space
                lda private_send_value
                sta fifo
                rts
                .pend

;-------------------------------------------------------------------------

send_payload_byte: .proc
                sta private_send_value
                ; .debug_print ['tube_serial.s_p_b: value=&',private_send_value,'; LSB -offset=&',scratch_payload_size+0,'\r']
                
                .wait_for_tx_space
                lda private_send_value
                sta fifo

                lda scratch_payload_size+0
                bne +
                
                ; .debug_print ['tube_serial.s_p_b: wait for TX space for confirmation byte\r']
                .wait_for_tx_space

                lda #1
                sta fifo
+
                ; .debug_print ['tube_serial.s_p_b: sent &',private_send_value,'\r']
                rts
                .pend

;-------------------------------------------------------------------------

recv_header_byte: .proc
                ; receive data byte
                .wait_for_rx_data
                lda fifo
                rts
                .pend

;-------------------------------------------------------------------------

recv_payload_byte: .proc
                ;.debug_print ['tube_serial.r_p_b: &',scratch_payload_size+0,'\r']
                lda scratch_payload_size+0
                bne +

                ;.debug_print ['tube_serial.r_p_b: await confirmation byte: &']

                ; receive and discard confirmation byte
                .wait_for_rx_data
                lda fifo

                ;.debug_print [DP_A,'\r']

+
                ;.debug_print ['tube_serial.r_p_b: await data byte\r']

                ; receive data byte
                .wait_for_rx_data
                lda fifo
                
                ;.debug_print ['tube_serial.r_p_b: got: &',DP_A,'\r']
                
                rts
                .pend
                
;-------------------------------------------------------------------------

                .bend
                
                .send code

;-------------------------------------------------------------------------
                
link_name='Tube Serial'
link_prepare=tube_serial.prepare
link_unprepare=tube_serial.unprepare

link_begin_recv=tube_serial.nop
link_begin_send=tube_serial.nop

link_send_header_byte=tube_serial.send_header_byte
link_send_payload_byte=tube_serial.send_payload_byte
link_recv_header_byte=tube_serial.recv_header_byte
link_recv_payload_byte=tube_serial.recv_payload_byte
                
link_startup=tube_serial.startup
link_status_text=tube_serial.status_text
                
link_send_file_data_parasite=send_file_data_parasite_bytewise
link_send_file_data_host=send_file_data_host_bytewise
link_recv_file_data_parasite=recv_file_data_parasite_bytewise
link_recv_file_data_host=recv_file_data_host_bytewise
