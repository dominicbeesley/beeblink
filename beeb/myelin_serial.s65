;-------------------------------------------------------------------------
;
; BeebLink - BBC Micro file storage system
;
; Copyright (C) 2019, 2020 Tom Seddon
; 
; This program is free software: you can redistribute it and/or
; modify it under the terms of the GNU General Public License as
; published by the Free Software Foundation, either version 3 of the
; License, or (at your option) any later version.
; 
; This program is distributed in the hope that it will be useful, but
; WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
; General Public License for more details.
; 
; You should have received a copy of the GNU General Public License
; along with this program. If not, see
; <https://www.gnu.org/licenses/>.
;


                .section code

                .cerror NUM_SERIAL_SYNC_ZEROS<0||NUM_SERIAL_SYNC_ZEROS>65535,'NUM_SERIAL_SYNC_ZEROS must be a 16-bit uint'

                ; makes a bit of a difference in FSTEST. 1.3x as many
                ; BGETs per second.
send_1_byte_messages=true
                
;-------------------------------------------------------------------------
                
                .virtual $fca0
fifo:
                .endv

                .virtual $fca1
status: .block
rx_data=$01
tx_space=$02
                .bend
                .endv

;-------------------------------------------------------------------------

myelin_serial: .block

txdp: .macro items
                ; .debug_print \items 
                .endm
                
;-------------------------------------------------------------------------

                .section link_startup_workspace
num_sync_zeros_received: .fill 2
startup_counter: .fill 2
startup_sync_counter: .fill 1
                .send link_startup_workspace

; ; The link startup workspace is a not-very-generous 8 bytes.
; startup_end_time=brkthunk+0
; startup_current_time=brkthunk+5
; startup_max_time=1000 ;in centiseconds
                
;-------------------------------------------------------------------------

                .section link_workspace
link_old_y: .fill 1
link_value: .fill 1
                .send link_workspace
                

;-------------------------------------------------------------------------
; Reads status register during startup. Handles Tube palaver if
; required.
;
; exit: A=value of status register
startup_read_status: .proc

                lda status
                rts

;-------------------------------------------------------------------------
; Read FIFO during startup. Handles Tube palaver if required.
;
; exit: C=0 if no data was available
;       C=1 if data was available, A = value read
startup_read_fifo: .proc

read_fifo:
                lda status
                and #status.rx_data
                bne got_data

no_data:
                clc
                rts

got_data:
                lda fifo
                sec
                rts

;-------------------------------------------------------------------------
; Write FIFO during startup. Handles Tube palaver if required.
;
; entry: Y=value to write
; exit: C=0 if no space
;       C=1 if data was written
startup_write_fifo: .proc

write_y_fifo:
                lda status
                and #status.tx_space
                bne space

no_space:
                clc
                rts

space:
                sty fifo
                sec
                rts

                
;-------------------------------------------------------------------------

startup: .proc

; During service call 3, IRQs appear to be disabled. So the startup
; process doesn't check the system clock - it just counts number of
; iterations of each of the various initialisation loops, and classes
; it as a timeout if some maximum number of iterations is exceeded.
;
; There's also a limit on how many times the sync process can be
; attempted overall, in case (as I've seen happen with the device
; unpowered) the device is falsely detected as present and the startup
; process ends up oscillating between states.

                lda #50
                sta startup_sync_counter

                lda #4
                jsr reset_startup_counter
wait_for_device_ready_loop:
                ldy #status_text.not_ready-status_text
                jsr check_startup_counter
                
                jsr startup_read_status
                
                ; wait for bit 3 to become set.
                and #status.configured
                beq wait_for_device_ready_loop

start_sync:
                dec startup_sync_counter
                beq failed
                
                lda #0
                sta num_sync_zeros_received+0
                sta num_sync_zeros_received+1

                .block
                .debug_print ['Sync step 0...\r\n']
                lda #1
                jsr reset_startup_counter
sync_step_0_loop:
                ldy #status_text.sync_timed_out_0-status_text
                jsr check_startup_counter

                ldy #$80
                jsr startup_write_fifo

                bcc sync_step_0_loop
                .bend

                .block
                .debug_print ['Sync step 1...\r\n']
                lda #255
                jsr reset_startup_counter
sync_step_1_loop:
; .print ['&00: sent: &',num_sync_zeros_sent+1,num_sync_zeros_sent+0,'; received: &',num_sync_zeros_received+1,num_sync_zeros_received+0,'\r\n']
                ldy #status_text.sync_timed_out_1-status_text
                jsr check_startup_counter

                ; Try to write $00. If it didn't get sent, no
                ; problem... plenty more where that came from.
                ldy #$00
                jsr startup_write_fifo
                
                ; Try to get more data. If none available, just carry
                ; on looping.
                jsr startup_read_fifo
                bcc sync_step_1_loop

                ; If a non-0 was received, restart the sync process.
                cmp #0
                bne start_sync

                ; Count one more zero received.
                ldx #num_sync_zeros_received
                jsr add1z16

                ; Keep going if required number not reached.
                lda num_sync_zeros_received+0
                cmp #<NUM_SERIAL_SYNC_ZEROS
                bne sync_step_1_loop

                lda num_sync_zeros_received+1
                cmp #>NUM_SERIAL_SYNC_ZEROS
                bne sync_step_1_loop
                .bend

                .block
                ; Keep reading until the 1 byte is received. Continue
                ; sending zeros meanwhile.
                .debug_print ['Sync step 2...\r\n']
                lda #16
                jsr reset_startup_counter
sync_step_2_loop:
                ldy #status_text.sync_timed_out_2-status_text
                jsr check_startup_counter

                ; Try to write $00. If it didn't get sent, no
                ; problem... plenty more where that came from.
                ldy #$00
                jsr startup_write_fifo

                jsr startup_read_fifo
                bcc sync_step_2_loop

                cmp #0
                beq sync_step_2_loop

                cmp #1
                bne failed
                .bend

                .block
                ; Send a single non-zero byte.
                .debug_print ['Sync step 3...\r\n']
                lda #16
                jsr reset_startup_counter
sync_step_3_loop:
                ldy #status_text.sync_timed_out_3-status_text
                jsr check_startup_counter

                ldy #$01
                jsr startup_write_fifo
                bcc sync_step_3_loop
                .bend
ok:
                .debug_print ['Sync success (probably)\r\n']
                clc             ;good
                rts

failed:
                ldx #status_text.sync_failed-status_text
                sec             ;no good
                rts

                ; A = counter/256
reset_startup_counter:
                eor #$ff
                clc
                adc #1
                sta startup_counter+1
                lda #0
                sta startup_counter+0
                rts
                
check_startup_counter:
                ldx #startup_counter
                jsr add1z16
                bne +
                ; naughty hack.
                pla
                pla
                tya
                tax
                ; ldx #status_text.sync_timed_out-status_text
                sec
+
                rts

                
                
                .pend

status_text: .block
not_ready:
                .text 'Device not ready',0
sync_failed:
                .text 'Sync failed',0
sync_timed_out_0:
                .text 'Sync timeout (step 0)',0
sync_timed_out_1:
                .text 'Sync timeout (step 1)',0
sync_timed_out_2:
                .text 'Sync timeout (step 2)',0
sync_timed_out_3:
                .text 'Sync timeout (step 3)',0
                .bend
                
;-------------------------------------------------------------------------
;
; Begin send.
; 
begin_send: .proc
                pha             ;save packet type

                .if send_1_byte_messages
                
                ; payload size 1?
                lda payload_counter+0
                cmp #1
                bne n_bytes     ;taken if payload size isn't $xxxxxx01

                lda payload_counter+1
                ora payload_counter+2
                ora payload_counter+3
                bne n_bytes     ;taken if payload size isn't $00000001

                pla             ;restore packet type
                and #$7f        ;clear the N-byte bit
                jsr send_header_byte ;send header type

                clc
                rts

                .endif

n_bytes:
                pla             ;restore packet type
                ora #$80        ;set the N-byte bit
                jsr send_header_byte ;send header type
                
                lda payload_counter+0
                jsr send_header_byte

                lda payload_counter+1
                jsr send_header_byte
                
                lda payload_counter+2
                jsr send_header_byte

                lda payload_counter+3
                jsr send_header_byte

                clc
                rts
                .pend

;-------------------------------------------------------------------------
;
; Begin recv.

begin_recv: .proc
                jsr recv_header_byte ;receive packet type

                cmp #$80        ;C=1 if N-byte
                and #$7f
                bcs n_bytes
                jmp set_payload_counter_1

n_bytes:
                pha
                jsr recv_header_byte
                sta payload_counter+0

                jsr recv_header_byte
                sta payload_counter+1

                jsr recv_header_byte
                sta payload_counter+2

                jsr recv_header_byte
                sta payload_counter+3

                pla
                
                rts
                
                .pend
                
;-------------------------------------------------------------------------
;
; Unprepare link.
;
; (Nothing needs to be done for the Tube serial.)
unprepare: .proc
                rts
                .pend

;-------------------------------------------------------------------------
;
; Placeholder for stuff I haven't done yet.
;
error: .proc
                .brk_error 255,'Myelin serial transfer = TODO'
                .pend

;-------------------------------------------------------------------------
;
; Placeholder for stuff that doesn't need doing.
;
nop: .proc
                rts
                .pend

        
                
;-------------------------------------------------------------------------
;
; Send a byte on B/B+/M128 with no Tube/ext Tube.
;
; entry: Y = value to send
; preserves: X
send_byte: .macro
                .txdp ['send_byte: sending &',DP_Y]

                lda #status.tx_space
-
                bit status
                beq -
                sty fifo
                .txdp ['\r\n']
                .endm

;-------------------------------------------------------------------------
;
; Receive a byte on B/B+/M128 with no Tube/ext Tube.
;
; entry:
; exit: A = byte received
; preserves: X

recv_byte: .macro
                .txdp ['recv_byte: received &']
                lda #status.rx_data
-
                bit status
                beq -
                lda fifo
                .txdp [DP_A,'\r\n']
                .endm
                
;-------------------------------------------------------------------------

send_header_byte: .proc
                sty link_old_y
                tay
                
                .send_byte
                ldy link_old_y
                rts

;-------------------------------------------------------------------------

send_payload_byte: .proc
                sty link_old_y
                
                tay
            
                .send_byte

                lda payload_counter+0
                bne +

                ldy #1
                .send_byte

+
                ldy link_old_y
                rts

;-------------------------------------------------------------------------

recv_header_byte: .proc
                
                ; receive data byte
                .recv_byte
                rts

;-------------------------------------------------------------------------

recv_payload_byte: .proc

                lda payload_counter+0
                beq recv_status_byte

recv_data_byte:
                .recv_byte
                rts

recv_status_byte:
                jsr recv_data_byte
                pha             ;save data byte

                .recv_byte

                pla             ;restore data byte
                rts


;-------------------------------------------------------------------------
;
; Transfer mode stuff.
;

; Fake enum. Supply these to the dir argument of any of the
; transfer-related macros.
send=1
recv=2

; Crude dir validity check.
check_dir: .macro dir
                .cerror \dir!=send&&\dir!=recv,'bad send/recv dir'
                .endm

; Get appropriate status register flag for dir.
get_status_flag_for_dir: .function dir
                .check_dir dir
                .endf dir==send?status.tx_space:status.rx_data
                
;-------------------------------------------------------------------------
;
; Generates driver routine for transferring file data. Sends N lead-up
; bytes, followed by a confirmation byte; then some number of pages,
; each followed by a confirmation byte.
;
; If \tube_dir is 0, no Tube code will be generated; if send or recv,
; Tube handling will be included.
;
; \bytes_routine is the bytes transfer routine to call.
;
; \page_routine is the page transfer routine to call. If 0,
; \bytes_routine will be called instead, with X=0 each time, to
; transfer 256 bytes.
; 
transfer_file_data_driver_routine: .macro tube_dir,bytes_routine,page_routine,name
                .if \tube_dir!=0
                .check_dir \tube_dir
                jsr claim_tube
                .endif

                jsr negate_payload_counter
                
                .txdp [\name,': &',payload_counter+0,' bytes, &',payload_counter+3,payload_counter+2,payload_counter+1,' pages\r\n']

                ; need to copy any bytes?
                lda payload_counter+0
                beq bytes_done

                .if \tube_dir!=0
                ldx #<payload_addr
                ldy #>payload_addr
                lda #\tube_dir==send?tube_multi_byte_parasite_to_host:tube_multi_byte_host_to_parasite
                jsr $406
                .endif

                ldx payload_counter+0
                jsr \bytes_routine

                ; update dest pointer
                clc
                lda payload_addr+0
                adc payload_counter+0
                sta payload_addr+0
                bcc +
                inc payload_addr+1
                bne +
                inc payload_addr+2
                bne +
                inc payload_addr+3
+

bytes_done:
                ; need to copy any pages?
                lda #0
                sta payload_counter+0
                jsr test_payload_counter
                beq done

                jsr negate_payload_counter
                ; payload_counter bits 8-31 is the negative page
                ; count.
pages_loop:
                .if \page_routine!=0
                
                .if \tube_dir!=0
                ldx #<payload_addr
                ldy #>payload_addr
                lda #\tube_dir==send?tube_256_byte_parasite_to_host:tube_256_byte_host_to_parasite
                jsr $406
                .endif

                jsr \page_routine
                
                .else

                ; (can continue to use existing Tube transfer mode, if
                ; any)
                
                ldx #0          ;transfer 256 bytes
                jsr \bytes_routine
                
                .endif

                inc payload_addr+1
                bne +
                inc payload_addr+2
                bne +
                inc payload_addr+3
+

                inc payload_counter+1 ;page count bits 0-7
                bne pages_loop
                inc payload_counter+2 ;page count bits 8-15
                bne pages_loop
                inc payload_counter+3 ;page count bits 16-23
                bne pages_loop
                
done:
                .if \tube_dir!=0
                jsr release_tube
                .endif

                rts

                .endm

;-------------------------------------------------------------------------
;
; Generate code to wait for appropriate FIFO readiness for the given
; direction.
;
; 8 cycles when straight through.
;
; exit: FIFO in hoped-for state
; preserves: X/Y
transfer_wait_for_status: .macro dir
                .check_dir \dir
                
                lda #get_status_flag_for_dir(\dir)
-
                bit status
                beq -
                .endm


;-------------------------------------------------------------------------
;
; Generate code to transfer a data byte between (payload_addr),y in
; host memory and FIFO.
;
; Send = 9/10 cycles
; Recv = 10 cycles
;
; entry: (payload_addr),y = host address
;        FIFO = in appropriate state for send/recv
; preserves: X/Y
transfer_host_data_byte: .macro dir
                .check_dir \dir
                
                .if \dir==send
                lda (payload_addr),y
                sta fifo
                .else
                lda fifo
                sta (payload_addr),y
                .endif
                
                .endm

;-------------------------------------------------------------------------
;
; Generate code to transfer a data byte between Tube FIFO and FTDI
; FIFO.
;
; Send = 8 cycles, Tube access on cycle +3
; Recv = 8 cycles, Tube access on cycle +7
;
; entry: FIFOs in appropriate state
; preserves: X

transfer_parasite_data_byte: .macro dir
                .check_dir \dir

                .if \dir==send
                ldy tube_fifo3_data
                sty fifo
                .else
                ldy fifo
                sty tube_fifo3_data
                .endif

                .endm

;-------------------------------------------------------------------------
;
; Generate code to transfer a status byte.
;
; entry: FIFO = in appropriate state
; preserves: X/Y
transfer_status_byte: .macro dir
                .check_dir \dir

                .if \dir==send
                lda #1
                sta fifo
                .else
                lda fifo        ;and discard it
                .endif

                .endm
                
;-------------------------------------------------------------------------
;
; Generate host bytes transfer routine.
;
transfer_host_bytes_routine: .macro dir
                .check_dir \dir

                ldy #0
loop:
                .transfer_wait_for_status \dir ;0 +8
                .transfer_host_data_byte \dir  ;8 +8

                iny             ;16 +2
                dex             ;18 +2
                bne loop        ;20 +3 = 23

                .transfer_wait_for_status \dir
                .transfer_status_byte \dir

                rts
                
                .endm


;-------------------------------------------------------------------------
;
; Generate host page transfer routine.
;
transfer_host_page_routine: .macro dir
                .check_dir \dir

bytes_per_iteration=8
                .cerror 256%bytes_per_iteration!=0,'no'

                ldy #0
loop:
                .rept bytes_per_iteration
                .transfer_wait_for_status \dir ;+8  8
                .transfer_host_data_byte \dir  ;+10 18
                iny                            ;+2  20
                .next                          ;20n

                bne loop

                .transfer_wait_for_status \dir
                .transfer_status_byte \dir

                rts
                
                .endm

;-------------------------------------------------------------------------
;
; Generate parasite bytes transfer routine.
;
; Min 24 usec/48 cycles per byte.
;
; entry: Tube FIFO ready for transfer mode 0/1
;        (recv) X+1 bytes incoming - X data bytes, 1 confirmation byte
transfer_parasite_bytes_routine: .macro dir
                .check_dir \dir

                .if \dir==send
                ; Combined with the jsr required to call the routine,
                ; this will give the required initial 48 cycle delay
                ; before the first Tube FIFO access.
                nop             ;6 +2
                bit $70         ;8 +3
                .endif
                
loop:
                .transfer_wait_for_status \dir    ;0 +8
                jsr delay_24_cycles               ;8 +24
                bit $70                           ;32 +3
                .transfer_parasite_data_byte \dir ;35 +8
                dex                               ;43 +2
                bne loop                          ;45 +3

                .transfer_wait_for_status \dir
                .transfer_status_byte \dir
                
                rts
                .endm

;-------------------------------------------------------------------------
;
; Generate parasite page transfer routine.
;
; Min 10 usec/20 cycles per byte.
;
; In the send direction, first Tube FIFO access is at cycle +14.
;
transfer_parasite_page_routine: .macro dir
                .check_dir \dir

                .if \dir==send
                ; Combined with the jsr required to call the routine,
                ; this will give the required initial 38 cycle delay
                ; before the first Tube FIFO access.
                jsr delay_12_cycles ;+12 18
                bit $70             ;+3  21
                bit $70             ;+3  24
                .endif

                ldx #0                             ;+2 
                lda #get_status_flag_for_dir(\dir) ;+2 
loop:
                bit status                        ;+4 4
                bne transfer                      ;+3 7
                beq loop                          ;...
transfer:                                         ;...
                .transfer_parasite_data_byte \dir ;+8 15
                inx                               ;+2 17
                bne loop                          ;+3 20

                .transfer_wait_for_status \dir
                .transfer_status_byte \dir
                
                rts
                .endm
                
;-------------------------------------------------------------------------
;
; Instantiations of the various macro-generated transfer routines, and
; some hand-written stuff.
;
; This is all just in any old order, whatever's necessary to fit each
; routine into 1 page so that the branch cycle counts are predictable
; :(

;-------------------------------------------------------------------------

                .align 256
                
;-------------------------------------------------------------------------

                .page
recv_host_bytes: .proc
                .transfer_host_bytes_routine recv
                .pend
                .endp

                .page
send_host_bytes: .proc
                .transfer_host_bytes_routine send
                .pend
                .endp
                
                .page
itu_recv_host_bytes: .proc
                .itu_transfer_host_bytes_routine recv
                .pend
                .endp

                .page
itu_send_host_bytes: .proc
                .itu_transfer_host_bytes_routine send
                .pend
                .endp

                .page
recv_parasite_bytes: .proc
                .transfer_parasite_bytes_routine recv
                .pend
                .endp

                .page
send_parasite_bytes: .proc
                .transfer_parasite_bytes_routine send
                 .pend
                .endp

;-------------------------------------------------------------------------

                .align 256
                
;-------------------------------------------------------------------------

                .page
send_host_page: .proc
                .transfer_host_page_routine send
                .pend
                .endp

                .align 256
                
                .page
itu_recv_host_page: .proc
                .itu_transfer_host_page_routine recv
                .pend
                .endp

                .align 256

                .page
itu_send_host_page: .proc
                .itu_transfer_host_page_routine send
                .pend
                .endp

                .page
recv_parasite_page: .proc
                .transfer_parasite_page_routine recv
                .pend
                .endp

                .page
send_parasite_page: .proc
                .transfer_parasite_page_routine send
                .pend
                .endp


recv_file_data_host: .proc

                .transfer_file_data_driver_routine 0,recv_host_bytes,recv_host_page,'recv_file_data_host'
                
                .pend

send_file_data_host: .proc

                .transfer_file_data_driver_routine 0,send_host_bytes,send_host_page,'send_file_data_host'

                .pend

recv_file_data_parasite: .proc

                .transfer_file_data_driver_routine recv,recv_parasite_bytes,recv_parasite_page,'recv_file_data_parasite'

                .pend

send_file_data_parasite: .proc

                .transfer_file_data_driver_routine send,send_parasite_bytes,send_parasite_page,'send_file_data_parasite'

                .pend
                
;-------------------------------------------------------------------------

                .bend
                
                .send code

;-------------------------------------------------------------------------
                
link_name='Myelin Serial'
link_subtype=SERIAL_SUBTYPE_MYELIN_SERIAL
                
link_unprepare=myelin_serial.unprepare

link_begin_send_without_restart=myelin_serial.begin_send
link_begin_send_with_restart=myelin_serial.begin_send

link_begin_recv=myelin_serial.begin_recv
                
link_send_payload_byte=myelin_serial.send_payload_byte
link_recv_payload_byte=myelin_serial.recv_payload_byte
                
link_startup=myelin_serial.startup
link_status_text=myelin_serial.status_text
                
link_send_file_data_parasite=myelin_serial.send_file_data_parasite

link_send_file_data_host=myelin_serial.send_file_data_host

link_recv_file_data_parasite=myelin_serial.recv_file_data_parasite

link_recv_file_data_host=myelin_serial.recv_file_data_host

link_num_speedtest_iterations=10

