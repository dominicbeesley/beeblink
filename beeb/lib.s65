;-------------------------------------------------------------------------
;
; BeebLink - BBC Micro file storage system
;
; Copyright (C) 2018, 2019, 2020 Tom Seddon
; 
; This program is free software: you can redistribute it and/or
; modify it under the terms of the GNU General Public License as
; published by the Free Software Foundation, either version 3 of the
; License, or (at your option) any later version.
; 
; This program is distributed in the hope that it will be useful, but
; WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
; General Public License for more details.
; 
; You should have received a copy of the GNU General Public License
; along with this program. If not, see
; <https://www.gnu.org/licenses/>.
;
;-------------------------------------------------------------------------

;-------------------------------------------------------------------------
; 
; Load word from memory and push onto stack.
;

push8 .macro
                lda \1
                pha
                .endm
                
push16 .macro
                push8 \1+1
                push8 \1+0
                .endm

push32 .macro
                push8 \1+3
                push8 \1+2
                push8 \1+1
                push8 \1+0
                .endm

push16zx: .macro
                lda 0,x
                pha
                lda 1,x
                pha
                .endm

push32zx: .macro
                lda 0,x
                pha
                lda 1,x
                pha
                lda 2,x
                pha
                lda 3,x
                pha
                .endm

;-------------------------------------------------------------------------
;
; Pop word from stack and store into memory.
;

pop8 .macro
                pla
                sta \1
                .endm
                
pop16 .macro
                pop8 \1
                pop8 \1+1
                .endm

pop32 .macro
                pop8 \1+0
                pop8 \1+1
                pop8 \1+2
                pop8 \1+3
                .endm

pop16zx: .macro
                pla
                sta 1,x
                pla
                sta 0,x
                .endm

pop32zx: .macro
                pla
                sta 3,x
                pla
                sta 2,x
                pla
                sta 1,x
                pla
                sta 0,x
                .endm
                
;-------------------------------------------------------------------------
;
; debug print nonsense.
;
; The macro's single argument is a list of items to print. Each item
; can be:
;
; string - string is printed as-is using oswrch
;
; 16-bit integer - print byte at that address, 2 hex digits
;
; DP_A, DP_X, DP_Y - print register, 2 hex digits
;
; DP_P - print P, 8 chars
;
; DP_WORD(A) - print LE word at address A, 4 hex digits
;
; DP_DWORD(A) - print LE dword at address A, 8 hex digits
;
; DP_IND(A,D) - ldy #D:lda (A),y - print byte, 2 hex digits
;
; print - always prints using oswrch
; preserves: A; X; Y: P
;
; debug_print - prints using oswrch if the debug verbosity flag is set
; preserves: A; X; Y; P

DP_A=-1
DP_X=-2
DP_Y=-3
DP_P=-4

DP_IND_TYPE=-1
DP_WORD_TYPE=-2
DP_DWORD_TYPE=-3
                
DP_IND: .sfunction _address,offset,(DP_IND_TYPE,_address,offset)
DP_WORD: .sfunction _address,(DP_WORD_TYPE,_address)
DP_DWORD: .sfunction _address,(DP_DWORD_TYPE,_address)

print: .macro items
                php             ;104=p
                pha             ;103=a
                txa
                pha             ;102=x
                tya
                pha             ;101=y
                tsx
                .for _i=0,_i<len(\items),_i+=1

                .if type(\items[_i])==str

                .if len(\items[_i])==1
                lda #\items[_i][0]
                jsr oswrch
                .elsif \items[_i]=='\r\n'
                jsr osnewl
                .else
                jsr pcprint
                .text \items[_i],255
                .endif
                
                .elsif type(\items[_i])==int||type(\items[_i])==bits||type(\items[_i])==code
                
                .if \items[_i]>=0&&\items[_i]<=65535
                lda \items[_i]
                jsr print_hex_byte
                .elsif \items[_i]==DP_A
                lda $103,x
                jsr print_hex_byte
                .elsif \items[_i]==DP_X
                lda $102,x
                jsr print_hex_byte
                .elsif \items[_i]==DP_Y
                lda $101,x
                jsr print_hex_byte
                .elsif \items[_i]==DP_P
                lda $104,x
                jsr print_p
                .else
                .cerror true,"bad debug_print integer"
                .endif

                .elsif type(\items[_i])==tuple
                
                .if \items[_i][0]==DP_IND_TYPE
                ldy #\items[_i][2]
                lda (\items[_i][1]),y
                jsr print_hex_byte
                .elsif \items[_i][0]==DP_WORD_TYPE
                ldx #\items[_i][1]
                jsr debug_print_hex.word
                .elsif \items[_i][0]==DP_DWORD_TYPE
                ldx #\items[_i][1]
                jsr debug_print_hex.dword
                .else
                .error "bad debug_print tuple"
                .endif
                
                .else

                .cerror true,"bad debug_print item: ",\items[_i]," ",type(\items[_i])

                .endif
                
                .next

                pla
                tay
                pla
                tax
                pla
                plp
                .endm

;-------------------------------------------------------------------------
;
;

debug_print .macro items,enabled=true
                .if enable_debug_print
                .if \enabled
                php             ;104=p
                jsr get_vstatus
                bcc +
                print list(\items)
+
                plp
                .endif
                .endif
                .endm
                
;-------------------------------------------------------------------------
;
;
;

strings_list .macro strings

addresses:=[]
strings:
                .for i=0,i<len(\strings),i+=1
addresses:=addresses..[*]
                .text \strings[i],255
                .next

l:
                .byte <addresses
h:
                .byte >addresses
                .endm

;-------------------------------------------------------------------------

brk_error .macro code,text
                jsr dobrk
                .text \code,\text,0
                .endm
                
;-------------------------------------------------------------------------

branch_same_page .macro target
                .cerror ((*+2)&$ff00)!=(\target&$ff00),"branch crosses page"
                .endm
                
beq_same_page .macro target
                .branch_same_page \target
                beq \target
                .endm

bne_same_page .macro target
                .branch_same_page \target
                bne \target
                .endm

bmi_same_page .macro target
                .branch_same_page \target
                bmi \target
                .endm

bpl_same_page .macro target
                .branch_same_page \target
                bpl \target
                .endm

bcc_same_page .macro target
                .branch_same_page \target
                bcc \target
                .endm

bcs_same_page .macro target
                .branch_same_page \target
                bcs \target
                .endm

bvc_same_page .macro target
                .branch_same_page \target
                bvc \target
                .endm

bvs_same_page .macro target
                .branch_same_page \target
                bvs \target
                .endm

;-------------------------------------------------------------------------

                .section lib_code
debug_print_hex: .proc
dword:
                lda 3,x
                jsr print_hex_byte
                lda 2,x
                jsr print_hex_byte
word:
                lda 1,x
                jsr print_hex_byte
                lda 0,x
                tsx
                jmp print_hex_byte
                .pend
                .endsection lib_code

;-------------------------------------------------------------------------

                